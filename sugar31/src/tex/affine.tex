% ===> this file was generated automatically by noweave --- better not edit it
\section{Introduction}

An \emph{affine} transformation is a transformation of the form
\[
  T(x) = Ax + b
\]
The {\Tt{}affine\nwendquote} module provides routines to create, apply, and
manipulate affine transformations on Euclidean 3-space.


\section{Interface}

\nwfilename{affine.nw}\nwbegincode{1}\sublabel{NW3kVjcs-3IKtGs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-3IKtGs-1}}}\moddef{affine.h~{\nwtagstyle{}\subpageref{NW3kVjcs-3IKtGs-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#ifndef AFFINE_H
#define AFFINE_H

\LA{}exported functions~{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-1}}\RA{}

#endif /* AFFINE_H */
\nwnotused{affine.h}\nwendcode{}\nwbegindocs{2}\nwdocspar

We represent affine transformations by a 3-by-4 double
precision matrix in column-major format.  The leading
3-by-3 submatrix represents the linear part ($A$),
and the trailing column vector represents the translation
($b$).

The {\Tt{}identity\nwendquote} function initializes the matrix to the
representation of the identity transform; $A = I$, $b = 0$.

\nwenddocs{}\nwbegincode{3}\sublabel{NW3kVjcs-2gXoUc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-1}}}\moddef{exported functions~{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-3IKtGs-1}}\nwprevnextdefs{\relax}{NW3kVjcs-2gXoUc-2}\nwenddeflinemarkup
void affine_identity(double* T);

\nwalsodefined{\\{NW3kVjcs-2gXoUc-2}\\{NW3kVjcs-2gXoUc-3}\\{NW3kVjcs-2gXoUc-4}}\nwused{\\{NW3kVjcs-3IKtGs-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

There are several functions which modify an existing
transformation $T$ by composing it with a simple transformation
$S$ to get a new transformation $ST$. 
In the {\Tt{}translate\nwendquote} and {\Tt{}translate{\_}xyz\nwendquote} functions, $S$ is
a simple translation ($A = 0$, $b$ is specified by the arguments).
The {\Tt{}rotate{\_}ox\nwendquote}, {\Tt{}rotate{\_}oy\nwendquote}, and {\Tt{}rotate{\_}oz\nwendquote} functions
apply rotations by some fixed number of radians about the $x$,
$y$, and $z$ axes, respectively.  The rotations are oriented
according to the right hand rule.  The {\Tt{}scale\nwendquote}, {\Tt{}scale{\_}x\nwendquote},
{\Tt{}scale{\_}y\nwendquote}, and {\Tt{}scale{\_}z\nwendquote} apply a scaling, either of all
variables or just of the individual components.

\nwenddocs{}\nwbegincode{5}\sublabel{NW3kVjcs-2gXoUc-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-2}}}\moddef{exported functions~{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-3IKtGs-1}}\nwprevnextdefs{NW3kVjcs-2gXoUc-1}{NW3kVjcs-2gXoUc-3}\nwenddeflinemarkup
void affine_translate    (double* T, double* c);
void affine_translate_xyz(double* T, double x, double y, double z);
void affine_rotate_ox    (double* T, double ox);
void affine_rotate_oy    (double* T, double oy);
void affine_rotate_oz    (double* T, double oz);
void affine_scale        (double* T, double s);
void affine_scale_x      (double* T, double s);
void affine_scale_y      (double* T, double s);
void affine_scale_z      (double* T, double s);
\nwused{\\{NW3kVjcs-3IKtGs-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

The {\Tt{}compose\nwendquote} function composes two transformations
to get $S := TS$.

\nwenddocs{}\nwbegincode{7}\sublabel{NW3kVjcs-2gXoUc-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-3}}}\moddef{exported functions~{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-3IKtGs-1}}\nwprevnextdefs{NW3kVjcs-2gXoUc-2}{NW3kVjcs-2gXoUc-4}\nwenddeflinemarkup
void affine_compose(double* T, double* S);

\nwused{\\{NW3kVjcs-3IKtGs-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

There are several versions of the {\Tt{}apply\nwendquote} transformation.
The basic {\Tt{}apply\nwendquote} transformation computes $x := T(x)$,
but there is also {\Tt{}apply{\_}A\nwendquote} to apply just the linear
part of the transformation ($x := Ax$), and {\Tt{}apply{\_}AT\nwendquote}
to apply the transpose of the linear part ($x := A^T x$).
The basic {\Tt{}apply\nwendquote} functions assume that the argument vector
is laid out contiguously in memory, but there are also
versions of the functions which assume the elements are
separated by a constant stride.

\nwenddocs{}\nwbegincode{9}\sublabel{NW3kVjcs-2gXoUc-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-4}}}\moddef{exported functions~{\nwtagstyle{}\subpageref{NW3kVjcs-2gXoUc-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-3IKtGs-1}}\nwprevnextdefs{NW3kVjcs-2gXoUc-3}{\relax}\nwenddeflinemarkup
void affine_apply          (double* T, double* x);
void affine_apply_stride   (double* T, double* x, int stride);
void affine_apply_A        (double* T, double* x);
void affine_apply_A_stride (double* T, double* x, int stride);
void affine_apply_AT       (double* T, double* x);
void affine_apply_AT_stride(double* T, double* x, int stride);

\nwused{\\{NW3kVjcs-3IKtGs-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

\section{Implementation}

\nwenddocs{}\nwbegincode{11}\sublabel{NW3kVjcs-dYkGQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-dYkGQ-1}}}\moddef{affine.c~{\nwtagstyle{}\subpageref{NW3kVjcs-dYkGQ-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#include <sugar.h>

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <affine.h>

\LA{}functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}\RA{}
\nwnotused{affine.c}\nwendcode{}\nwbegindocs{12}\nwdocspar

\nwenddocs{}\nwbegincode{13}\sublabel{NW3kVjcs-nRuDO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{\relax}{NW3kVjcs-nRuDO-2}\nwenddeflinemarkup
void affine_identity(double* T)
\{
    memset(T, 0, 12*sizeof(double));
    T[0] = 1;
    T[4] = 1;
    T[8] = 1;
\}

\nwalsodefined{\\{NW3kVjcs-nRuDO-2}\\{NW3kVjcs-nRuDO-3}\\{NW3kVjcs-nRuDO-4}\\{NW3kVjcs-nRuDO-5}\\{NW3kVjcs-nRuDO-6}\\{NW3kVjcs-nRuDO-7}\\{NW3kVjcs-nRuDO-8}\\{NW3kVjcs-nRuDO-9}\\{NW3kVjcs-nRuDO-A}\\{NW3kVjcs-nRuDO-B}\\{NW3kVjcs-nRuDO-C}}\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

Note that the {\Tt{}translate\nwendquote} function overwrites $T$ with
the composition of translation with $T$, not with the
composition of $T$ with the translation.  The same holds
for the rotations.

\nwenddocs{}\nwbegincode{15}\sublabel{NW3kVjcs-nRuDO-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-2}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-1}{NW3kVjcs-nRuDO-3}\nwenddeflinemarkup
void affine_translate(double* T, double* c)
\{
    T[9 ] += c[0];
    T[10] += c[1];
    T[11] += c[2];
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

\nwenddocs{}\nwbegincode{17}\sublabel{NW3kVjcs-nRuDO-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-3}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-2}{NW3kVjcs-nRuDO-4}\nwenddeflinemarkup
void affine_translate_xyz(double* T, double x, double y, double z)
\{
    T[9 ] += x;
    T[10] += y;
    T[11] += z;
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

The rotation functions obey the right-hand rule, which usually
confuses me.  That is why there is a sign reversal on the angle
for the rotation about the $y$ axis.  Since these are purely
linear transformations, we just need to transform each column
of $T$ in turn.

\nwenddocs{}\nwbegincode{19}\sublabel{NW3kVjcs-nRuDO-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-4}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-3}{NW3kVjcs-nRuDO-5}\nwenddeflinemarkup
void affine_rotate_ox(double* T, double ox)
\{
    double c = cos(ox);
    double s = sin(ox);
    int i;

    for (i = 0; i < 4; ++i) \{
        double y =  c*T[1] + s*T[2];
        double z = -s*T[1] + c*T[2];
        T[1] = y;
        T[2] = z;
        T += 3;
    \}
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

\nwenddocs{}\nwbegincode{21}\sublabel{NW3kVjcs-nRuDO-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-5}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-4}{NW3kVjcs-nRuDO-6}\nwenddeflinemarkup
void affine_rotate_oy(double* T, double oy)
\{
    double c =  cos(oy);
    double s = -sin(oy);
    int i;

    for (i = 0; i < 4; ++i) \{
        double x =  c*T[0] + s*T[2];
        double z = -s*T[0] + c*T[2];
        T[0] = x;
        T[2] = z;
        T += 3;
    \}
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar

\nwenddocs{}\nwbegincode{23}\sublabel{NW3kVjcs-nRuDO-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-6}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-5}{NW3kVjcs-nRuDO-7}\nwenddeflinemarkup
void affine_rotate_oz(double* T, double oz)
\{
    double c = cos(oz);
    double s = sin(oz);
    int i;

    for (i = 0; i < 4; ++i) \{
        double x =  c*T[0] + s*T[1];
        double y = -s*T[0] + c*T[1];
        T[0] = x;
        T[1] = y;
        T += 3;
    \}
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

The {\Tt{}scale\nwendquote} function scales everything in sight by the given constant.

\nwenddocs{}\nwbegincode{25}\sublabel{NW3kVjcs-nRuDO-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-7}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-6}{NW3kVjcs-nRuDO-8}\nwenddeflinemarkup
void affine_scale(double* T, double s)
\{
    int i;
    for (i = 0; i < 12; ++i)
        *T++ *= s;
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{26}\nwdocspar

The {\Tt{}scale{\_}x\nwendquote}, {\Tt{}scale{\_}y\nwendquote}, and {\Tt{}scale{\_}z\nwendquote} functions only scale
the appropriate rows.

\nwenddocs{}\nwbegincode{27}\sublabel{NW3kVjcs-nRuDO-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-8}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-7}{NW3kVjcs-nRuDO-9}\nwenddeflinemarkup
void affine_scale_x(double* T, double s)
\{
    int row = 0;
    \LA{}scale row~{\nwtagstyle{}\subpageref{NW3kVjcs-yJ7l-1}}\RA{}
\}

void affine_scale_y(double* T, double s)
\{
    int row = 1;
    \LA{}scale row~{\nwtagstyle{}\subpageref{NW3kVjcs-yJ7l-1}}\RA{}
\}

void affine_scale_z(double* T, double s)
\{
    int row = 2;
    \LA{}scale row~{\nwtagstyle{}\subpageref{NW3kVjcs-yJ7l-1}}\RA{}
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar

\nwenddocs{}\nwbegincode{29}\sublabel{NW3kVjcs-yJ7l-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-yJ7l-1}}}\moddef{scale row~{\nwtagstyle{}\subpageref{NW3kVjcs-yJ7l-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-nRuDO-8}}\nwenddeflinemarkup
int i;
for (i = 0; i < 4; ++i, T += 3)
    T[row] *= s;
\nwused{\\{NW3kVjcs-nRuDO-8}}\nwendcode{}\nwbegindocs{30}\nwdocspar

The {\Tt{}compose\nwendquote} function does \emph{not} necessarily do a purely
linear transformation.  The composition $TS$ will have the form
\begin{eqnarray*}
  TS(x) & = & A_T (A_S x + b_S) + b_T \\
        & = & A_T A_S x + T(b_S)
\end{eqnarray*}
So we apply $A_T$ to the first three columns of $S$, and then
apply $T$ to the last column of $S$.

\nwenddocs{}\nwbegincode{31}\sublabel{NW3kVjcs-nRuDO-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-9}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-8}{NW3kVjcs-nRuDO-A}\nwenddeflinemarkup
void affine_compose(double* T, double* S)
\{
    int i;
    for (i = 0; i < 3; ++i) \{
        double y[3];

        y[0] = T[0]*S[0] + T[3]*S[1] + T[6]*S[2];
        y[1] = T[1]*S[0] + T[4]*S[1] + T[7]*S[2];
        y[2] = T[2]*S[0] + T[5]*S[1] + T[8]*S[2];

        S[0] = y[0];
        S[1] = y[1];
        S[2] = y[2];

        S += 3;
    \}

    affine_apply(T, S);
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{32}\nwdocspar

The {\Tt{}apply\nwendquote}, {\Tt{}apply{\_}A\nwendquote}, and {\Tt{}apply{\_}AT\nwendquote} functions are
implemented as simple wrappers around their strided
counterparts.

\nwenddocs{}\nwbegincode{33}\sublabel{NW3kVjcs-nRuDO-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-A}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-9}{NW3kVjcs-nRuDO-B}\nwenddeflinemarkup
void affine_apply(double* T, double* x)
\{
    affine_apply_stride(T, x, 1);
\}

void affine_apply_stride(double* T, double* x, int stride)
\{
    double x0 = x[0*stride];
    double x1 = x[1*stride];
    double x2 = x[2*stride];

    x[0*stride] = T[0]*x0 + T[3]*x1 + T[6]*x2 + T[9 ];
    x[1*stride] = T[1]*x0 + T[4]*x1 + T[7]*x2 + T[10];
    x[2*stride] = T[2]*x0 + T[5]*x1 + T[8]*x2 + T[11];
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{34}\nwdocspar

\nwenddocs{}\nwbegincode{35}\sublabel{NW3kVjcs-nRuDO-B}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-B}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-A}{NW3kVjcs-nRuDO-C}\nwenddeflinemarkup
void affine_apply_A(double* T, double* x)
\{
    affine_apply_A_stride(T, x, 1);
\}

void affine_apply_A_stride(double* T, double* x, int stride)
\{
    double x0 = x[0*stride];
    double x1 = x[1*stride];
    double x2 = x[2*stride];

    x[0*stride] = T[0]*x0 + T[3]*x1 + T[6]*x2;
    x[1*stride] = T[1]*x0 + T[4]*x1 + T[7]*x2;
    x[2*stride] = T[2]*x0 + T[5]*x1 + T[8]*x2;
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}\nwbegindocs{36}\nwdocspar

\nwenddocs{}\nwbegincode{37}\sublabel{NW3kVjcs-nRuDO-C}\nwmargintag{{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-C}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW3kVjcs-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3kVjcs-dYkGQ-1}}\nwprevnextdefs{NW3kVjcs-nRuDO-B}{\relax}\nwenddeflinemarkup
void affine_apply_AT(double* T, double* x)
\{
    affine_apply_AT_stride(T, x, 1);
\}

void affine_apply_AT_stride(double* T, double* x, int stride)
\{
    double x0 = x[0*stride];
    double x1 = x[1*stride];
    double x2 = x[2*stride];

    x[0] = T[0]*x0 + T[1]*x1 + T[2]*x2;
    x[1] = T[3]*x0 + T[4]*x1 + T[5]*x2;
    x[2] = T[6]*x0 + T[7]*x1 + T[8]*x2;
\}

\nwused{\\{NW3kVjcs-dYkGQ-1}}\nwendcode{}

\nwixlogsorted{c}{{affine.c}{NW3kVjcs-dYkGQ-1}{\nwixd{NW3kVjcs-dYkGQ-1}}}%
\nwixlogsorted{c}{{affine.h}{NW3kVjcs-3IKtGs-1}{\nwixd{NW3kVjcs-3IKtGs-1}}}%
\nwixlogsorted{c}{{exported functions}{NW3kVjcs-2gXoUc-1}{\nwixu{NW3kVjcs-3IKtGs-1}\nwixd{NW3kVjcs-2gXoUc-1}\nwixd{NW3kVjcs-2gXoUc-2}\nwixd{NW3kVjcs-2gXoUc-3}\nwixd{NW3kVjcs-2gXoUc-4}}}%
\nwixlogsorted{c}{{functions}{NW3kVjcs-nRuDO-1}{\nwixu{NW3kVjcs-dYkGQ-1}\nwixd{NW3kVjcs-nRuDO-1}\nwixd{NW3kVjcs-nRuDO-2}\nwixd{NW3kVjcs-nRuDO-3}\nwixd{NW3kVjcs-nRuDO-4}\nwixd{NW3kVjcs-nRuDO-5}\nwixd{NW3kVjcs-nRuDO-6}\nwixd{NW3kVjcs-nRuDO-7}\nwixd{NW3kVjcs-nRuDO-8}\nwixd{NW3kVjcs-nRuDO-9}\nwixd{NW3kVjcs-nRuDO-A}\nwixd{NW3kVjcs-nRuDO-B}\nwixd{NW3kVjcs-nRuDO-C}}}%
\nwixlogsorted{c}{{scale row}{NW3kVjcs-yJ7l-1}{\nwixu{NW3kVjcs-nRuDO-8}\nwixd{NW3kVjcs-yJ7l-1}}}%
\nwbegindocs{38}\nwdocspar


\nwenddocs{}
